
int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

printf("hello, world"); #printf equals to 'say' in Scratch
                        #semicolon ';' presents the end of the thought

get_string("What's your name? ") #get_string equals to 'ask' in Scratch
string answer = get_string("What's your name? "); #we copy the answer into a variable named 'answer'

#return value: a piece of information, being stored somewhere, where we can make use of it later
printf("hello, %s", answer); #first comma is a grammatical one, while the second comma separates the first argument from the second one

#include <stdio.h>
int main(void) #this is how you start writing a program
{

}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

include #<stdio.h>
int main(void)
{
    // Greet user #a remainder of what that line does
    printf("hello, world")
}


STANDARD COMMANDS
------------------------------------------------------------------------------------------------------------------------------------------

'ls' = Linus shell command: prints all the files and directories in the present directory in the form of a list

'rm document_name' =asks to remove that document from the directory (typing 'y' or 'yes' approves the action itself)
'rmdir' = remove directory

'mv' = move command: mv hello.c goodbye.c it moves a file to another location or under another name

'mkdir directory_name' = make directory (for example, named 'lecture')

we can move the document_file (hello.c) into directory: 'mv hello.c lecture/'

we can check what is inside a certain directory by typing the 'cd lecture/' into terminal 
the result is: /lecture/ and by typing 'ls' we get a response (a list), showing us what is inside that directory

'mv hello.c' .. means that we remove the folder from the directory (directory is empty): the folder is now equal to the directory
'..' reffers to your parent directory
'.' reffers to your current directory

'./hello.c' tells the computer to run the program called 'hello.c' in the current directory

'cp' = copy


BASIC CALCULATOR
------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    int x = get_int("x: "); #int = integer (uses only 32 bits): number without decimal points (..., -3, -2, -1, 0, 1, 2, 3, ...)
    int y = get_int("y: ");
    printf("%i", x + y);         # %i is a plceholder for a unknown number
}

we then type into terminal 'make addition' (= name of the file)
if no errors occur, we are prompted to type individually 'x' and 'y' values into the terminal
and the result (addition of the x and y) is seen on terminal

if anything else than an integer is writen into terminal as it asks from x and y values,
terminal ignores the answer and asks for it again
if the number is too high (with 32 bits you can roughly count to as high as 4 billion: either in positive or negative numbers)
but if we want to include both negative and positive numbers, we can only count 2 billion into each direction

long = longer integer (64 bits long)

int main(void)
{
    long x = get_long("x: "); 
    long y = get_long("y: ");
    printf("%li", x + y);    
}

change 'int' into 'long'
the program doesnt work: error is that instead of placeholder '&i' we now have to use '%li' which stands for long integer

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    // Get numbers from user (comment)
    int x = get_int("x: "); #float: short for floating point value: a real number
    int y = get_int("y: ");
   
    // Divide x by y
    float z = x /y;
    printf("%f", z);    
}

bug: improper use of C
if both x and y are integers, by definition: you're gonna get back an integer: but you lose all the decimal points 
changing int into float would fix that problem
instead: float z = (float) x / (float) y; we can convert x and y into a float and then do the math

------------------------------------------------------------------------------------------------------------------------------------------

int counter = 0; (set counter to 0)

#adding + 1 to a variable:
counter = counter + 1;
counter += 1;
counter++;

if (x < y)
{
    printf("x is less than y")
}
else if (x > y)
{
    printf("x is not less than y")
}
else
{
    printf("x is equal to y")
}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
   char c = get_char("Do you agree? "); #char requires a single quote
   if (c == 'y' || C == 'Y') # || means 'or'
   {
       printf("Agreed.")
   }
   else if (c == 'n' || C == 'N')
   {    
       printf("Not agreed.")
   }
}

# a program takes only n and y, not N and Y

------------------------------------------------------------------------------------------------------------------------------------------

while (true) #infinite loop
{
  
}

int i = 0;
while (i < 50) #finite loop
{
   printf("hello, world");
   i++;
}


for (int counter = 0; i <50; i++) #the best way in C to do a repetitive action finite number of times
{
   printf("hello, world"); 
}

------------------------------------------------------------------------------------------------------------------------------------------

abstraction: 

void meow(void); #showing the compailer that a function meow exists at the bottom

int main(void)
{
   for (int i = 0; i <3; i++)
   {
      meow();
   }
}



void meow(int n)
{
   for (int i = 0; i < n; i++)
   {
   printf("meow");
   }
}

# void: the absence of input/output
------------------------------------------------------------------------------------------------------------------------------------------

NESTED LOOP:

int main(void)
{
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         printf("#");
      }
      printf("\n"); #moves it into next line
   }
}

RETURN: 
###
###
###

------------------------------------------------------------------------------------------------------------------------------------------

printf("%f\n", x / y); #gives a certain number of decimal points
printf("%.10f\n", x / y); #gives 10 decimal points: impercision (a computer can only give a finite number of decimal points, after that it approximates)

integer overflow:
000
001
010
100
101
110
111 = 7

------------------------------------------------------------------------------------------------------------------------------------------

make hello
./hello

CLANG: compiller that turns source code into machine code
clang hello.c 
ls
a.out
rm a.out

COMMAND: clang -o hello hello.c = run clang, output hello from the hello.c

#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

terminal: make hello = clang -o hello hello.c -lcs50 (-l = link; without it there is an error)

-lcrypt crypto library
-lm math library

stdio.h
cs50.h
help50
style50
check50
printf

------------------------------------------------------------------------------------------------------------------------------------------

DEBUGGING CODE:

#include <stdio.h>

int main(void)
{
   // print 10 hashes
   for (int = 0; i <= 10; i++)
   {
      printf("i is now %i\n", i); #we can add a line: we can use printf to see the value of i
      printf("#\n");
    }
}

make buggy0: no error, but it prints 11 hashes instead of 10
by adding this "printf("i is now %i\n", i);" we can clearly see which hash belongs to what number
changing <= to < gives us 10 hashes


debug50: runs the code step by step
debug50 ./buggy0

control + C will always break you out of the program


#include <cs50.h>
#include <stdio.h>

int get_negative_int(void)

int main(void)
{
   int i = get_negative_int();
   printf("%\n", i);
}

int get_negative_int(void)
{
   int n;
   do
   {
     n = get_int("Negative Integer: ")
   }
   while (n < 0); #source of the bug: change is: while (n > 0);
   return n;
}

rubber duck debugging

------------------------------------------------------------------------------------------------------------------------------------------

ARRAYS: sequences of values stored in a memory back to back

the average:

int main(void)
{
   int score1 = 72;
   int score2 = 73;
   int score3 = 33;
   
   
   improving the design of code:
   
   int scores[3];  the number inside the brackets tells us how many integers can we store in array
   score[0] = 72;  we have to start counting from zero
   score[1] = 73;  when declaring the number of arrays, inside the bracket is the total number of values
   score[2] = 33;  
   
if there is at least one float, the result will also be a float (not integer) as it is more powerful


const int TOTAL = 3; # the value cannot change, CAPITAL LETTERS SIGNIFY THAT IT'S A DIFFERENT KIND OF NUMBER

int main(void)
{   
   int scores[TOTAL];  
   for (int i = 0, i < TOTAL, i++)
   {
      scores[i] = get_int("Score: ");  
   }
   
   print("Average: %f\n", average(TOTAL, scores));
}

// a function that computes the average
float average(int length, int array[])
{
   int sum = 0;
   for (int i = 0; i < length; i++)
   {
      sum = sum + array[i];
   }
   return sum / (float) length;
}

---------------------------------------------------------------------------------------

CASTING THE CHARACTER: 
char: single character: single quotes
string: multiple characters: double quotes

int main(void)
{ 
   char c = '#'
   
   print("%i\n", c);
}
terminal: 35 a number assigned to # in ASCII


int main(void)
{ 
   string s = "HI!";
   
   print("%s\n", c);
}
terminal: HI! or 72, 73, 33

a string is an array

s[0] = H = 72
s[1] = I = 73
s[2] = ! = 33
s[3] = \0 NUL: 4th byte: a special character that represents the end of string = 0
a string is an array

program that prints out the length of the string

int main(void)
{
   string s = get_string("Input: ");
   printf("Output: ");
   for (int i = 0; s[i] != '\0'; i++) # when to stop printing a string: print as long as a character in string does not equal NUL
   {                                  # != does not equal
      printf("%c", s[i]);
   }
}
s[i] != '\0' in C equals to i < strlen(s) (string lenght) in file <string.h> (#include)


so that we don't repeat the same function over and over, we can introduce variable n

int main(void)
{
   string s = get_string("Input: ");
   printf("Output: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {                                  
      printf("%c", s[i]);
   }
}

---------------------------------------------------------------------------------------

an array of arrays:

string words[0]
words[0] = "Hi!"   words[0][0] = H, words[0][1] = i, ...
words[1] = "Bye!"  words[1][0] = B, words[1][1] = y, ...


a program that converts an input word into an uppercase

#include <cs50.h>
#include <stdio.h>
#include <ctype.h>

int main(void)
{
   string s = get_string("Before: ");
   printf("After: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {
      if (s[i] >= 'a' && s[i] <= 'z')  # if s[i] is greater than a and less than z
      {                                # in ASCII lower and upper letters are consistently 32 places apart
         printf("%c", s[i] - 32);
      }
   }
   else
   {
      printf("%c", s[i]);
   }
}

a better version of this:
add #include <string.h> 

int main(void)
{
   string s = get_string("Before: ");
   printf("After: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {
      printf("%c", toupper(s[i]));   #toupper expects a character so the loop is important as it defines each character
   }  
}

---------------------------------------------------------------------------------------

command-line argument: for example 'hello'

#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[]) # function main takes an integer and an array of strings
{
   if (argc ==2)
   {
      printf("hello, %s\n", argv[1]);  # [1] means that the second word typed into terminal is used next to 'hello'
   }
   else
   {
      printf("hello, world\n");
   }
}

if the user types 2 words at the prompt, it will return 'hello, name', otherwise it will just say 'hello, world'
the program lets user to type into terminal any number of words:
if two words are typed (including ./argv), the second word will be printed next to 'hello'
if more or less than 2 words are typed, the program will return 'hello, world'

terminal: make argv
./argv = hello, world
./argv David = hello, David
./argv Brian Yu = hello, world


#include <cs50.h>
#include <stdio.h>
#include <string.h> 

int main(int argc, string argv[]) # function main takes an integer and an array of strings
{
   if (argc ==2)
   {
      for (int i = 0, n = strlen(argv[1]); i < n; i++)
      {
         printf("%c\n", argv[1][i]);
      }
   }
}
Terminal: ./argv David = vertically spelled D a v i d (printing one character at the time)


an exit status:

#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
   if (argc != 2)
   {
      printf("missing command-line argument\n");
      return 1;
   }
   printf("hello, %s\n", argv[1]);
   return 0;
}

Terminal: ./exit = missing command-line argument
          ./exit David = hello, David

---------------------------------------------------------------------------------------

crypting the text:
plaintext(input) + key - cipher - ciphertext(output)

-------------------------------------------------------------------------------------------------------------

ALGORITHMS:
running time of an algorithm: how long it takes, how many steps it has (unit of messure is not important)
big O notation: describes a running time of algorithm
Ω omega notation: discribes the lower bound (how many steps does an algorithm minimally takes)

LINEAR SEARCH: searching the book page by page

PSEUDO CODE FOR LINEAR SEARCH: 
For i from 0 to n-1
   If number behind i'th door
       Return true
Return false
       
efficency:
upper bound on the running time: O(n) in the worst case, it will be the last one
lower bound on the running time: Ω(1) in the best case we can find it in first try


#include <cs50.h>
#include <stdio.h>

int main(void)
{
   int numbers[] = {4, 6, 8, 2, 7, 5, 0}; #values of array
   
   for (int i = 0; i < 7; i++)
   {
      if (numbers[i] == 0)
      {
         printf("Found\n");
         return 0; 
      }
   }
   printf("Not found\n");
   return 1;  
}
main always returns int, so it's usefull to add the exit code 0 (success: program exits) and 1 


#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
   string names[] = {"Bill", "Charlie", "Fred", "George", "Ginny", "Percy", "Ron"}; # no need to input the size of array
                                                                                    
   for (int i = 0; i < 7; i++)
   {
      if (strcmp(names[i], "Ron") == 0)
      {
         printf("Found\n");
         return 0; 
      }
   }
   printf("Not found\n");
   return 1;  
}

string compare(compares every character by changing them to their ASCII code; case sensitive) has 3 possible outcomes: 
strings are equal: returns the value 0
first string is supposed to come before the second string: returns a negative value
first string is supposed to come after the second string: returns a positive value

line 588: only when the strcmp line == 0, do we have a match


typedef struct  # allows to define new data types (here: person)
{
   string name;
   string number;
}
person;

Phonebook program:

#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
   string name;
   string number;
}
person;

const int NUMBER = 10;
int main(void)
{
   person people[NUMBER];
   
   people[0].name = "Brian";
   people[0].number = "+1-617-495-1000";
   
   people[1] = "David";
   people[1].number = "+1-792-910-8319";
   
   ...
   
   for(int i = 0; i < 10; i++)
   {
      if (strcmp(people[i].name; "David") == 0)
      {
         printf("Found %s\", people[i].number);
         return 0;
      }
   }
   printf("Not founf\n");
   return 1;
}


BINARY SEARCH: data has to be sorted

pseudo code:
If no doors
    Return false
If number is behind middle door
   Return true
Else if number < middle door
   Search left half
Else if number > middle door
   Search right half
   
efficency:
upper bound on the running time: O(log n) max
lower bound on the running time: Ω(1) min


SELECTION SORT: 
upper bound: n(n + 1)/2 = n*2/2 + n/2 = O(n*2) slow
lower bound: Ω(n*2) slow

Pseudo code:
For i from 0 to n-1
   Find smallest item between i'th item and last item
   Swap smallest item with i'th item


BUBBLE SORT: the biggest numbers start bubbling their way to the end of the list
We look at pair of numbers and move the bigger number to the right side of the pair and repeat, 
so the highest number goes to the back of the list

Pseudo code:
Repeat until sorted
   For i from 0 to n-2
      If i'th and i+1'th elemens out of order
         Swap them
   If no swap
      Quit
      
lower bound: Ω(n)
upper bound: (n - 1)x(n - 1) = O(n*2) equivalent to the selection sort: slow


RECURSION or MERGE SORT: the ability for a function to call itself
Uses more space as it needs a second array

Pseudo code:
If only one number
   Quit
Else
   Sort right half of numbers    # sort = sort left, sort right and merge
   Sort left half of numbers
   Merge sorted halves

merge: the smallest number of the combined array needs to begin with either 
       the smallest number of the left or right array, we then build the 
       sorted array with picking the smallest numbers
We sort 4 to halves, and then halves to 1, sort each halves (arrays of sizes 2) and then merge them to array size 4

lower bound: Ω(log n) fast
upper bound: O(n log n) fast
----------------------------------------------------------------------------------------------------------------------------












