
int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

printf("hello, world"); #printf equals to 'say' in Scratch
                        #semicolon ';' presents the end of the thought

get_string("What's your name? ") #get_string equals to 'ask' in Scratch
string answer = get_string("What's your name? "); #we copy the answer into a variable named 'answer'

#return value: a piece of information, being stored somewhere, where we can make use of it later
printf("hello, %s", answer); #first comma is a grammatical one, while the second comma separates the first argument from the second one

#include <stdio.h>
int main(void) #this is how you start writing a program
{

}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

include #<stdio.h>
int main(void)
{
    // Greet user #a remainder of what that line does
    printf("hello, world")
}


STANDARD COMMANDS
------------------------------------------------------------------------------------------------------------------------------------------

'ls' = Linus shell command: prints all the files and directories in the present directory in the form of a list

'rm document_name' =asks to remove that document from the directory (typing 'y' or 'yes' approves the action itself)
'rmdir' = remove directory

'mv' = move command: mv hello.c goodbye.c it moves a file to another location or under another name

'mkdir directory_name' = make directory (for example, named 'lecture')

we can move the document_file (hello.c) into directory: 'mv hello.c lecture/'

we can check what is inside a certain directory by typing the 'cd lecture/' into terminal 
the result is: /lecture/ and by typing 'ls' we get a response (a list), showing us what is inside that directory

'mv hello.c' .. means that we remove the folder from the directory (directory is empty): the folder is now equal to the directory
'..' reffers to your parent directory
'.' reffers to your current directory

'./hello.c' tells the computer to run the program called 'hello.c' in the current directory

'cp' = copy


BASIC CALCULATOR
------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    int x = get_int("x: "); #int = integer (uses only 32 bits): number without decimal points (..., -3, -2, -1, 0, 1, 2, 3, ...)
    int y = get_int("y: ");
    printf("%i", x + y);         # %i is a plceholder for a unknown number
}

we then type into terminal 'make addition' (= name of the file)
if no errors occur, we are prompted to type individually 'x' and 'y' values into the terminal
and the result (addition of the x and y) is seen on terminal

if anything else than an integer is writen into terminal as it asks from x and y values,
terminal ignores the answer and asks for it again
if the number is too high (with 32 bits you can roughly count to as high as 4 billion: either in positive or negative numbers)
but if we want to include both negative and positive numbers, we can only count 2 billion into each direction

long = longer integer (64 bits long)

int main(void)
{
    long x = get_long("x: "); 
    long y = get_long("y: ");
    printf("%li", x + y);    
}

change 'int' into 'long'
the program doesnt work: error is that instead of placeholder '&i' we now have to use '%li' which stands for long integer

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    // Get numbers from user (comment)
    int x = get_int("x: "); #float: short for floating point value: a real number
    int y = get_int("y: ");
   
    // Divide x by y
    float z = x /y;
    printf("%f", z);    
}

bug: improper use of C
if both x and y are integers, by definition: you're gonna get back an integer: but you lose all the decimal points 
changing int into float would fix that problem
instead: float z = (float) x / (float) y; we can convert x and y into a float and then do the math

------------------------------------------------------------------------------------------------------------------------------------------

int counter = 0; (set counter to 0)

#adding + 1 to a variable:
counter = counter + 1;
counter += 1;
counter++;

if (x < y)
{
    printf("x is less than y")
}
else if (x > y)
{
    printf("x is not less than y")
}
else
{
    printf("x is equal to y")
}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
   char c = get_char("Do you agree? "); #char requires a single quote
   if (c == 'y' || C == 'Y') # || means 'or'
   {
       printf("Agreed.")
   }
   else if (c == 'n' || C == 'N')
   {    
       printf("Not agreed.")
   }
}

# a program takes only n and y, not N and Y

------------------------------------------------------------------------------------------------------------------------------------------

while (true) #infinite loop
{
  
}

int i = 0;
while (i < 50) #finite loop
{
   printf("hello, world");
   i++;
}


for (int counter = 0; i <50; i++) #the best way in C to do a repetitive action finite number of times
{
   printf("hello, world"); 
}

------------------------------------------------------------------------------------------------------------------------------------------

abstraction: 

void meow(void); #showing the compailer that a function meow exists at the bottom

int main(void)
{
   for (int i = 0; i <3; i++)
   {
      meow();
   }
}



void meow(int n)
{
   for (int i = 0; i < n; i++)
   {
   printf("meow");
   }
}

# void: the absence of input/output
------------------------------------------------------------------------------------------------------------------------------------------

NESTED LOOP:

int main(void)
{
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         printf("#");
      }
      printf("\n"); #moves it into next line
   }
}

RETURN: 
###
###
###

------------------------------------------------------------------------------------------------------------------------------------------

printf("%f\n", x / y); #gives a certain number of decimal points
printf("%.10f\n", x / y); #gives 10 decimal points: impercision (a computer can only give a finite number of decimal points, after that it approximates)

integer overflow:
000
001
010
100
101
110
111 = 7

------------------------------------------------------------------------------------------------------------------------------------------

make hello
./hello

CLANG: compiller that turns source code into machine code
clang hello.c 
ls
a.out
rm a.out

COMMAND: clang -o hello hello.c = run clang, output hello from the hello.c

#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

terminal: make hello = clang -o hello hello.c -lcs50 (-l = link; without it there is an error)

-lcrypt crypto library
-lm math library

stdio.h
cs50.h
help50
style50
check50
printf

------------------------------------------------------------------------------------------------------------------------------------------

DEBUGGING CODE:

#include <stdio.h>

int main(void)
{
   // print 10 hashes
   for (int = 0; i <= 10; i++)
   {
      printf("i is now %i\n", i); #we can add a line: we can use printf to see the value of i
      printf("#\n");
    }
}

make buggy0: no error, but it prints 11 hashes instead of 10
by adding this "printf("i is now %i\n", i);" we can clearly see which hash belongs to what number
changing <= to < gives us 10 hashes


debug50: runs the code step by step
debug50 ./buggy0

control + C will always break you out of the program


#include <cs50.h>
#include <stdio.h>

int get_negative_int(void)

int main(void)
{
   int i = get_negative_int();
   printf("%\n", i);
}

int get_negative_int(void)
{
   int n;
   do
   {
     n = get_int("Negative Integer: ")
   }
   while (n < 0); #source of the bug: change is: while (n > 0);
   return n;
}

rubber duck debugging

------------------------------------------------------------------------------------------------------------------------------------------

ARRAYS: sequences of values stored in a memory back to back

the average:

int main(void)
{
   int score1 = 72;
   int score2 = 73;
   int score3 = 33;
   
   
   improving the design of code:
   
   int scores[3];  the number inside the brackets tells us how many integers can we store in array
   score[0] = 72;  we have to start counting from zero
   score[1] = 73;  when declaring the number of arrays, inside the bracket is the total number of values
   score[2] = 33;  
   
if there is at least one float, the result will also be a float (not integer) as it is more powerful


const int TOTAL = 3; # the value cannot change, CAPITAL LETTERS SIGNIFY THAT IT'S A DIFFERENT KIND OF NUMBER

int main(void)
{   
   int scores[TOTAL];  
   for (int i = 0, i < TOTAL, i++)
   {
      scores[i] = get_int("Score: ");  
   }
   
   print("Average: %f\n", average(TOTAL, scores));
}

// a function that computes the average
float average(int length, int array[])
{
   int sum = 0;
   for (int i = 0; i < length; i++)
   {
      sum = sum + array[i];
   }
   return sum / (float) length;
}



