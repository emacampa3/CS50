
browser = client
server = backend

http-server: a program that runs a web server, that is listening for connections at port 80 or 443
GET /index.html HTTP/1.1.  give me a default webpage
GET /search?q=cats HTTP/1.1  Google search

FLASK: a framework (how to use the library) and a library (in other languages there are different frameworks)
when creating the simplest flask application, you tipically organize your files and folders in this way:

application.py
requirement.text
static/
templates/

MVC design pattern: 
model: techniques, data that the application is using
view: user interface
controller: files that control web application


a simple Flask application: 

from flask import Flask, render_template

app = Flask(__name__)                                                     # line of code that turns the current file into an application

@app.route("/")                                                           # route = url, @ = python decorator: applying one function to another
def indx():                                                               # defining a function
    return render_template("index.html", name=request.args.get("name"))   # args = arguments

TERMINAL: command: flask run


separately we create index.html file:
this file is a template: a file in which we can plug other values

<!DOCTYPE html>

<!DOCTYPE html>  DOCUMENT

<html lang="en">
    <head>  
        <title>hello</title>
    </head>
    <body> 
        hello, {{ name }}  # this means 'plug in any value typed into 'name''
    </body>
</html>

now when we run flask, it will run the index.html on web: 'hello, None': None means no value in python
if we add the the url: /?name=David, line will change to 'hello, David'

this variable supports a second argument:
name=request.args.get("name", "world"))  so with no name argument, the default value will be 'world'

@app.route("/") 
@app.route("/secret") if we want to access this file on web, we additionally have to type secret into the url  



index.html
<!DOCTYPE html>  DOCUMENT

<html lang="en">
    <head>  
        <title>hello</title>
    </head>
    <body> 
        <form action="/greet" method= "get">
            <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
            <input type="submit">
        </form>
    </body>
</html>


greet.html
<html lang="en">
    <head>  
        <title>hello</title>
    </head>
    <body> 
        hello, {{ name }}
    </body>
</html>


application.py
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/")     
def indx():                                
    return render_template("index.html")

@app.route("/greet")
def greet():
    return render_template("greet.html", name=request.args.get("name", "world"))

now we have 2 routes: the fisr one displays only the static form, the second one greets the user

POORLY DESIGN: we are leaking information into url, it will be saved to a browser
in index.html file we change method="get" to method="post" 
in application.py we have to add another argument to the @app.route("/greet", methods=["POST"]) # the default is get, so we have to override it
moreover in application.py we need to change: name=request.form.get("name", "world"))
request.args: for get
request.form: for post
now we have removed personal information from the url line

another poorly designed thing: we are repeating lines in html files: 
frameworks support the ability to clean this up a bit by creating another file, by convention called layout.html in templates directory

layout.html
greet.html
<html lang="en">
    <head>  
        <title>hello</title>
    </head>
    <body>
        {% block body%}{% endblock %}    # Flask specific sintax: a placeholder
    </body>
</html>


after that we delete in index.html file everything apart from the essence:
here comes so code you can plug into a placeholder

index.html
{% extends "layout.html" %}

{% block body %}

    <form action="/greet" method= "get">
        <input autocomplete="off" autofocus name="name" placeholder="Name" type="text">
        <input type="submit">
    </form>

{% end block %}

we can also delete the redundancy in greet.html:
{% extends "layout.html" %}

{% block body %}

  hello, {{ name }}
    
{% end block %}

in application.py we can mix together the two routes into one:
application.py
from flask import Flask, render_template

app = Flask(__name__)

@app.route("/", methods=["GET", "POST"])     
def indx():
    if request.method == "GET":
        return render_template("index.html")
    if request.method == "POST":
        return render_template("greet.html", name=request.form.get("name", "world"))

in index.html we also have to change <form action="/" method="post">













