
SQL (Structured Query Language) is a domain-specific language used in programming and designed for managing data held 
in a relational database management system, or for stream processing in a relational data 
stream management system. 

spreadsheets: 
good for quickly sorting, storing large amounts/rows/columns of data: limited to computers memory
adding more data to the bottom, it grows vertically

flat-file database: simple design, for example: CSV (comma separated values) cannot store functions
problem: if in the spreadsheet name or some value contains a comma, 
that could be confused with the comma separating rows of the spreadsheet:
solution is to use double quotes for a string that contains commas, to keep it uniformed


after having a spreadsheet in csv, we can open it in Python:

import csv

titles = set()                                                         # throws away the duplicates

with open("Favourite TV Shows - Form Responses 1.csv", "r") as file:   # opening a csv file in read-only mode
    reader csv.DictReader(file)                                        # dictionary reader
    for row in reader:
        titles.add(row["title"].strip().upper())                      # we can add new titles to the titles: throwing away duplicate values, only printing out the unique titles
                                                                         changing the titles all to .upper: so we shouldn't get duplicates based on case sensitivity
for title in sorted(titles):                                           # sorting the results with a function in Python named 'sorted'
    print(title)
    
.strip: removes all the white space on both sides of the string
in Python we can add more functions together
after all that our data is clean (we get a list without duplicates), apart from the typos


FAVOURITE TV SHOWS:
import csv

titles = {}                                                       

with open("Favourite TV Shows - Form Responses 1.csv", "r") as file:   
    reader csv.DictReader(file)                                        
    for row in reader:
        title = row["title"].strip().upper()
        if title in titles:
            titles[title] += 1                                         # goes to the dictionary under the correct title and adds 1 to whatever value is there already
        else:
            titles[title] = 0                                          # we can go into a dictionary, using a key that does or doesn't exist: if it does, 
                                                                         add 1 to its value, otherwise set it to 0      
def f(titles):                                                         # a short function f that for every title returns the value associated with it
    return titles[title]
    
for title in sorted(titles, key=f, reverse=True):                      # we can override the function sorted()
    print(title, titles[title])                                        # we can print more values: print function will put a space between them



dict() = {}: create a dictionary 

sorted() sorts dictionaries by keys, not value: so we need a function to sort the titles by value
sorted() also has another optional parameter: reverse=True that just reverses the order

we could define a new function 'f' that returns the value of the key: the dictinary will now be sorted by value
in Python you can pass around functions as arguments by their name

key=f(): calling a function would be wrong, as without () the sorted() function can rather call the f function 
         over and over again, rather than calling it only once

in Python if we have simple functions as 'f': we can use it without defining it
lambda: gives us a function without a name that only cares about arguments and return values: key=lambda argument_name: return_value

def f(titles):
    return titles[title]

for title in sorted(titles, key=lambda title: titles[title], reverse=True):
that way we don't need to keep defining new functions


instead of this:
if title in titles:
            titles[title] += 1
        else:
            titles[title] = 0

we can use:
if title not in titles:
    titles[titles] = 0
titles[title] += 1                  # same as before but shorter: also we are not adding anything 
                                      to the dictionary until we are sure title is indeed in there

THE WHOLE PROGRAM:
import csv

titles = {}                                                       

with open("Favourite TV Shows - Form Responses 1.csv", "r") as file:   
    reader csv.DictReader(file)                                        
    for row in reader:
        title = row["title"].strip().upper()
        if title not in titles:
            titles[titles] = 0
        titles[title] += 1   
                                                            
for title in sorted(titles, key=lambda title: titles[title], reverse=True):               
    print(title, titles[title])
    
TERMINAL: returns the list of titles in order of descending values


NEW PROGRAM: search for the specific show in csv file and return the popularity of it
import csv

title = input("Title: ").strip().upper()

with open("Favourite TV Shows - Form Responses 1.csv", "r") as file:
    reader = csv.DictReader(file)
    counter = 0
    for row in reader:
        if row["title"].strip().upper() == title:
            counter += 1

print(counter)
TERMINAL: Title: The Office: the answer is 26

Running time of the program: 0(n) linear search
Flat-file database: useful for smaller data sets


RELATIONAL DATABASES: implemented in software, offer more functions: we can search, insert new or delete the data more efficently
those databases store the information in tables

SQLite: light version of SQL: stores data in a binary file
sqlite3: command-line tool: allows you to interact with tables

commands:
.mode csv
.import imported_file_name new_table_name (takes 2 arguments)

new language SQL (Structured Query Language) used for interactions with relational databases
4 basic operations supported by any relational database: CREATE, READ, UPDATE, DELETE: CRUD (acronym)
in SQL: CREATE, INSERT
        SELECT (reading the database)
        UPDATE
        DELETE

syntax used to create a table in SQL
CREATE TABLE table (column type, ...);
SELECT columns FROM table; in our case: SELECT title FROM shows (look at row 'title' in file 'shows')

WHERE: condition 8select all the data where this is true/false)
LIKE: similar to something: % sign represents 0 or more characters in each way (is case insensitive)
ORDER BY
LIMIT
GROUP BY

examples: typing this into terminal
SELECT title FROM shows WHERE title LIKE "%Office%";
the result is list of all titles similar to The Office

SELECT DISTINCT(UPPER(title)) FROM shows ORDER BY UPPER(title);
the results are alphabetized thanks to 'ORDER BY'

SELECT UPPER(TRIM(title)), COUNT(title) FROM shows GROUP BY UPPER(TRIM(title)) ORDER BY COUNT(title) DESC; 
result: group the same titles (also the ones similar to them) and keep count of the number, in descending order
we can then save the binary file: file_name.db

SELECT title FROM shows WHERE genres LIKE "%Music&"; as long as the word Music is in genre: that includes Musical, which is esentially a bug

CREATE TABLE table (column type, ...);
INSERT INTO table (column, ...) VALUES(value, ...);

inserting new rows into a database:
INSERT INTO shows (Timestamp, title, genres) VALUES("now", "The Muppet Show", "Comedy, Musical");

updating the genres where title euqals to "The Muppet Show":
UPDATE shows SET genres = "comedy, Drama, Musical" WHERE title = "The Muppet Show";

deleting a certain show from the database:
DELETE FROM shows WHERE title LIKE "Friends";


SIMPLER TABLE: messy comma separated values in 'genres' will be moved to their own table
               but genres will be associated with the show_id

in SQLite there are 5 main data types:
BLOB (binary large object)
INTEGER: smallint, integer, bigint
NUMBERIC (number like): boolean, date, datetime, numeric(scale,precision), time, timestamp)
REAL (decimal point value): real, double precision
TEXT: char(n): always the same number of characters, varchar(n): specifies the maximum number of characters, text

NOT NULL (cannot be NULL)
UNIQUE (must be unique): can be ID (primary key: column in a table, that uniquely identifies each row)

primary keys: uniquely identifies each row
foreign keys: primary keys but inside a different table


PYTHON PROGRAM THAT CREATES TWO TABLES: one called 'shows' and the other 'genres', in for loop goes over the 
                                        csv file and inserts some data into one and some into another table
import csv
from cs50 import SQL             # allows to load a SQL database into memory

open("shows.db", "w").close      # we open the file (in write mode) and close it right away: means that we are creating an empty file
db = SQL("sqlite:///shows.db")   # opening the file

db.execute("CREATE TABLE shows (id INTEGER, title TEXT, PRIMARY KEY(ID)")      # we are combining python with SQL: we are storing the SQL commands into a Python strings and using them
db.execute("CREATE TABLE genres (show_id INTEGER, genre TEXT, FOREIGN KEY(show_id) REFERENCES shows(id)")

with open("Favourite TV Shows - Form Responses 1.csv", "r") as file:
    reader = csv.DictReader(file)
    for row in reader:
        if row["title"].strip().upper() == title:
        
        db.execute("INSERT INTO shows (title) VALUES(?)", title)      # inserting the values into a database
        for genre in row["genres"].split(", "):
                db.execute("INSERT INTO genres (show_id, genre) VALUES(?, ?)", id, genre)
        
in SQL: '?' is a place-holder

TERMINAL:
we now have a file named 'shows.db'
sqlite3 shows.db:  we can see what is inside of it
.schema:  lets us see what tables exist
SELECT * FROM shows;  the result is a list of numbers with the shows
SELECT * FROM shows WHERE title = "THE OFFICE";  we can see all the shows witht hat name and their unique numbers/ids
SELECT * FROM genres;  we see show_ids and their genres: one show can have more genres
SELECT * FROM genres WHERE genre = "Musical";  we get show_ids that have 'Musical' genre 
SELECT title FROM shows WHERE id IN (SELECT * FROM genres WHERE genre = "Musical");  we get the same result as before but instead of ids we get the actual titles of shows
SELECT DISTINCT(genre) FROM genres WHERE show_id IN (SELECT id FROM shows WHERE title = "THE OFFICE");  genres of The Office SHOW

we can add another table called 'shows_genres', which can be between 'shows' and 'genres' that contains 'show_id' and 'genre_id'
MANY-TO-MANY RELATIONSHIPS: one genre can have more shows and one show can have many genres


JOIN: allows you to join tables together
SELECT title FROM shows WHERE id IN (SELECT show_id FROM stars WHERE person_id = (SELECT id FROM people WHERE name = "Steve Carell"));
result: all the shows that Steve Carell was a part of


CREATE INDEX person_index ON stars (person_id);
CREATE INDEX show_index ON stars (show_id);
CREATE INDEX name_index ON people (name);

SELECT title FROM PEOPLE
JOIN stars ON people.id = stars.person_id
JOIN shows ON stars.show_id = shows.id
WHERE name = "Steve Carell";
result: all the shows that Steve Carell was a part of
THE FASTEST SEARCH


SQL INJECTION ATTACKS:
line of code in Python that might exist in backend as authentication:

rows = db.execute("SELECT * FROM users WHERE username = ? AND password = ?", username, password)

if len(rows) == 1:
    # LOg user in

this is good code: safe from injection attacks

if we used Pythons approach and asked for email and password using {}: user could type their email, 
following with '--' equaling a comment and in that way tricking the server into ignoring the password input:
consequently, someone could log into a site without the password

DROP: deletes a database in SQL


RACE CONDITIONS: 
multiserver: example: if we want to add +1 to some number and both servers get the same task simultaneously, 
they could both just want to add +1 to the same number, resulting in a missing +1

if one server is in the middle of checking for a variable, the other server should be locked out, 
not allowed to check for variable as well
TRANSACTIONS: allow you to lock a line of code until another servers work is executed

