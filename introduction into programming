
int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

printf("hello, world"); #printf equals to 'say' in Scratch
                        #semicolon ';' presents the end of the thought

get_string("What's your name? ") #get_string equals to 'ask' in Scratch
string answer = get_string("What's your name? "); #we copy the answer into a variable named 'answer'

#return value: a piece of information, being stored somewhere, where we can make use of it later
printf("hello, %s", answer); #first comma is a grammatical one, while the second comma separates the first argument from the second one

#include <stdio.h>
int main(void) #this is how you start writing a program
{

}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

include #<stdio.h>
int main(void)
{
    // Greet user #a remainder of what that line does
    printf("hello, world")
}


STANDARD COMMANDS
------------------------------------------------------------------------------------------------------------------------------------------

'ls' = Linus shell command: prints all the files and directories in the present directory in the form of a list

'rm document_name' =asks to remove that document from the directory (typing 'y' or 'yes' approves the action itself)
'rmdir' = remove directory

'mv' = move command: mv hello.c goodbye.c it moves a file to another location or under another name

'mkdir directory_name' = make directory (for example, named 'lecture')

we can move the document_file (hello.c) into directory: 'mv hello.c lecture/'

we can check what is inside a certain directory by typing the 'cd lecture/' into terminal 
the result is: /lecture/ and by typing 'ls' we get a response (a list), showing us what is inside that directory

'mv hello.c' .. means that we remove the folder from the directory (directory is empty): the folder is now equal to the directory
'..' reffers to your parent directory
'.' reffers to your current directory

'./hello.c' tells the computer to run the program called 'hello.c' in the current directory

'cp' = copy


BASIC CALCULATOR
------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    int x = get_int("x: "); #int = integer (uses only 32 bits): number without decimal points (..., -3, -2, -1, 0, 1, 2, 3, ...)
    int y = get_int("y: ");
    printf("%i", x + y);         # %i is a plceholder for a unknown number
}

we then type into terminal 'make addition' (= name of the file)
if no errors occur, we are prompted to type individually 'x' and 'y' values into the terminal
and the result (addition of the x and y) is seen on terminal

if anything else than an integer is writen into terminal as it asks from x and y values,
terminal ignores the answer and asks for it again
if the number is too high (with 32 bits you can roughly count to as high as 4 billion: either in positive or negative numbers)
but if we want to include both negative and positive numbers, we can only count 2 billion into each direction

long = longer integer (64 bits long)

int main(void)
{
    long x = get_long("x: "); 
    long y = get_long("y: ");
    printf("%li", x + y);    
}

change 'int' into 'long'
the program doesnt work: error is that instead of placeholder '&i' we now have to use '%li' which stands for long integer

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
    // Get numbers from user (comment)
    int x = get_int("x: "); #float: short for floating point value: a real number
    int y = get_int("y: ");
   
    // Divide x by y
    float z = x /y;
    printf("%f", z);    
}

bug: improper use of C
if both x and y are integers, by definition: you're gonna get back an integer: but you lose all the decimal points 
changing int into float would fix that problem
instead: float z = (float) x / (float) y; we can convert x and y into a float and then do the math

------------------------------------------------------------------------------------------------------------------------------------------

int counter = 0; (set counter to 0)

#adding + 1 to a variable:
counter = counter + 1;
counter += 1;
counter++;

if (x < y)
{
    printf("x is less than y")
}
else if (x > y)
{
    printf("x is not less than y")
}
else
{
    printf("x is equal to y")
}

------------------------------------------------------------------------------------------------------------------------------------------

int main(void)
{
   char c = get_char("Do you agree? "); #char requires a single quote
   if (c == 'y' || C == 'Y') # || means 'or'
   {
       printf("Agreed.")
   }
   else if (c == 'n' || C == 'N')
   {    
       printf("Not agreed.")
   }
}

# a program takes only n and y, not N and Y

------------------------------------------------------------------------------------------------------------------------------------------

while (true) #infinite loop
{
  
}

int i = 0;
while (i < 50) #finite loop
{
   printf("hello, world");
   i++;
}


for (int counter = 0; i <50; i++) #the best way in C to do a repetitive action finite number of times
{
   printf("hello, world"); 
}

------------------------------------------------------------------------------------------------------------------------------------------

abstraction: 

void meow(void); #showing the compailer that a function meow exists at the bottom

int main(void)
{
   for (int i = 0; i <3; i++)
   {
      meow();
   }
}



void meow(int n)
{
   for (int i = 0; i < n; i++)
   {
   printf("meow");
   }
}

# void: the absence of input/output
------------------------------------------------------------------------------------------------------------------------------------------

NESTED LOOP:

int main(void)
{
   for (int i = 0; i < 3; i++)
   {
      for (int j = 0; j < 3; j++)
      {
         printf("#");
      }
      printf("\n"); #moves it into next line
   }
}

RETURN: 
###
###
###

------------------------------------------------------------------------------------------------------------------------------------------

printf("%f\n", x / y); #gives a certain number of decimal points
printf("%.10f\n", x / y); #gives 10 decimal points: impercision (a computer can only give a finite number of decimal points, after that it approximates)

integer overflow:
000
001
010
100
101
110
111 = 7

------------------------------------------------------------------------------------------------------------------------------------------

make hello
./hello

CLANG: compiller that turns source code into machine code
clang hello.c 
ls
a.out
rm a.out

COMMAND: clang -o hello hello.c = run clang, output hello from the hello.c

#include <cs50.h>
#include <stdio.h>

int main(void)
{
    string answer = get_string("What's your name?? ");
    print("hello, %s, answer");
}

terminal: make hello = clang -o hello hello.c -lcs50 (-l = link; without it there is an error)

-lcrypt crypto library
-lm math library

stdio.h
cs50.h
help50
style50
check50
printf

------------------------------------------------------------------------------------------------------------------------------------------

DEBUGGING CODE:

#include <stdio.h>

int main(void)
{
   // print 10 hashes
   for (int = 0; i <= 10; i++)
   {
      printf("i is now %i\n", i); #we can add a line: we can use printf to see the value of i
      printf("#\n");
    }
}

make buggy0: no error, but it prints 11 hashes instead of 10
by adding this "printf("i is now %i\n", i);" we can clearly see which hash belongs to what number
changing <= to < gives us 10 hashes


debug50: runs the code step by step
debug50 ./buggy0

control + C will always break you out of the program


#include <cs50.h>
#include <stdio.h>

int get_negative_int(void)

int main(void)
{
   int i = get_negative_int();
   printf("%\n", i);
}

int get_negative_int(void)
{
   int n;
   do
   {
     n = get_int("Negative Integer: ")
   }
   while (n < 0); #source of the bug: change is: while (n > 0);
   return n;
}

rubber duck debugging

------------------------------------------------------------------------------------------------------------------------------------------

ARRAYS: sequences of values stored in a memory back to back

the average:

int main(void)
{
   int score1 = 72;
   int score2 = 73;
   int score3 = 33;
   
   
   improving the design of code:
   
   int scores[3];  the number inside the brackets tells us how many integers can we store in array
   score[0] = 72;  we have to start counting from zero
   score[1] = 73;  when declaring the number of arrays, inside the bracket is the total number of values
   score[2] = 33;  
   
if there is at least one float, the result will also be a float (not integer) as it is more powerful


const int TOTAL = 3; # the value cannot change, CAPITAL LETTERS SIGNIFY THAT IT'S A DIFFERENT KIND OF NUMBER

int main(void)
{   
   int scores[TOTAL];  
   for (int i = 0, i < TOTAL, i++)
   {
      scores[i] = get_int("Score: ");  
   }
   
   print("Average: %f\n", average(TOTAL, scores));
}

// a function that computes the average
float average(int length, int array[])
{
   int sum = 0;
   for (int i = 0; i < length; i++)
   {
      sum = sum + array[i];
   }
   return sum / (float) length;
}

---------------------------------------------------------------------------------------

CASTING THE CHARACTER: 
char: single character: single quotes
string: multiple characters: double quotes

int main(void)
{ 
   char c = '#'
   
   print("%i\n", c);
}
terminal: 35 a number assigned to # in ASCII


int main(void)
{ 
   string s = "HI!";
   
   print("%s\n", c);
}
terminal: HI! or 72, 73, 33

a string is an array

s[0] = H = 72
s[1] = I = 73
s[2] = ! = 33
s[3] = \0 NUL: 4th byte: a special character that represents the end of string = 0
a string is an array

program that prints out the length of the string

int main(void)
{
   string s = get_string("Input: ");
   printf("Output: ");
   for (int i = 0; s[i] != '\0'; i++) # when to stop printing a string: print as long as a character in string does not equal NUL
   {                                  # != does not equal
      printf("%c", s[i]);
   }
}
s[i] != '\0' in C equals to i < strlen(s) (string lenght) in file <string.h> (#include)


so that we don't repeat the same function over and over, we can introduce variable n

int main(void)
{
   string s = get_string("Input: ");
   printf("Output: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {                                  
      printf("%c", s[i]);
   }
}

---------------------------------------------------------------------------------------

an array of arrays:

string words[0]
words[0] = "Hi!"   words[0][0] = H, words[0][1] = i, ...
words[1] = "Bye!"  words[1][0] = B, words[1][1] = y, ...


a program that converts an input word into an uppercase

#include <cs50.h>
#include <stdio.h>
#include <ctype.h>

int main(void)
{
   string s = get_string("Before: ");
   printf("After: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {
      if (s[i] >= 'a' && s[i] <= 'z')  # if s[i] is greater than a and less than z
      {                                # in ASCII lower and upper letters are consistently 32 places apart
         printf("%c", s[i] - 32);
      }
   }
   else
   {
      printf("%c", s[i]);
   }
}

a better version of this:
add #include <string.h> 

int main(void)
{
   string s = get_string("Before: ");
   printf("After: ");
   for (int i = 0, n = strlen(s); i < n; i++)
   {
      printf("%c", toupper(s[i]));   #toupper expects a character so the loop is important as it defines each character
   }  
}

---------------------------------------------------------------------------------------

command-line argument: for example 'hello'

#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[]) # function main takes an integer and an array of strings
{
   if (argc ==2)
   {
      printf("hello, %s\n", argv[1]);  # [1] means that the second word typed into terminal is used next to 'hello'
   }
   else
   {
      printf("hello, world\n");
   }
}

if the user types 2 words at the prompt, it will return 'hello, name', otherwise it will just say 'hello, world'
the program lets user to type into terminal any number of words:
if two words are typed (including ./argv), the second word will be printed next to 'hello'
if more or less than 2 words are typed, the program will return 'hello, world'

terminal: make argv
./argv = hello, world
./argv David = hello, David
./argv Brian Yu = hello, world


#include <cs50.h>
#include <stdio.h>
#include <string.h> 

int main(int argc, string argv[]) # function main takes an integer and an array of strings
{
   if (argc ==2)
   {
      for (int i = 0, n = strlen(argv[1]); i < n; i++)
      {
         printf("%c\n", argv[1][i]);
      }
   }
}
Terminal: ./argv David = vertically spelled D a v i d (printing one character at the time)


an exit status:

#include <cs50.h>
#include <stdio.h>

int main(int argc, string argv[])
{
   if (argc != 2)
   {
      printf("missing command-line argument\n");
      return 1;
   }
   printf("hello, %s\n", argv[1]);
   return 0;
}

Terminal: ./exit = missing command-line argument
          ./exit David = hello, David

---------------------------------------------------------------------------------------

crypting the text:
plaintext(input) + key - cipher - ciphertext(output)

-------------------------------------------------------------------------------------------------------------

ALGORITHMS:
running time of an algorithm: how long it takes, how many steps it has (unit of messure is not important)
big O notation: describes a running time of algorithm
Ω omega notation: discribes the lower bound (how many steps does an algorithm minimally takes)

LINEAR SEARCH: searching the book page by page

PSEUDO CODE FOR LINEAR SEARCH: 
For i from 0 to n-1
   If number behind i'th door
       Return true
Return false
       
efficency:
upper bound on the running time: O(n) in the worst case, it will be the last one
lower bound on the running time: Ω(1) in the best case we can find it in first try


#include <cs50.h>
#include <stdio.h>

int main(void)
{
   int numbers[] = {4, 6, 8, 2, 7, 5, 0}; #values of array
   
   for (int i = 0; i < 7; i++)
   {
      if (numbers[i] == 0)
      {
         printf("Found\n");
         return 0; 
      }
   }
   printf("Not found\n");
   return 1;  
}
main always returns int, so it's usefull to add the exit code 0 (success: program exits) and 1 


#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
   string names[] = {"Bill", "Charlie", "Fred", "George", "Ginny", "Percy", "Ron"}; # no need to input the size of array
                                                                                    
   for (int i = 0; i < 7; i++)
   {
      if (strcmp(names[i], "Ron") == 0)
      {
         printf("Found\n");
         return 0; 
      }
   }
   printf("Not found\n");
   return 1;  
}

string compare(compares every character by changing them to their ASCII code; case sensitive) has 3 possible outcomes: 
strings are equal: returns the value 0
first string is supposed to come before the second string: returns a negative value
first string is supposed to come after the second string: returns a positive value

line 588: only when the strcmp line == 0, do we have a match


typedef struct  # allows to define new data types (here: person)
{
   string name;
   string number;
}
person;

Phonebook program:

#include <cs50.h>
#include <stdio.h>
#include <string.h>

typedef struct
{
   string name;
   string number;
}
person;

const int NUMBER = 10;
int main(void)
{
   person people[NUMBER];
   
   people[0].name = "Brian";
   people[0].number = "+1-617-495-1000";
   
   people[1] = "David";
   people[1].number = "+1-792-910-8319";
   
   ...
   
   for(int i = 0; i < 10; i++)
   {
      if (strcmp(people[i].name; "David") == 0)
      {
         printf("Found %s\", people[i].number);
         return 0;
      }
   }
   printf("Not founf\n");
   return 1;
}


BINARY SEARCH: data has to be sorted

pseudo code:
If no doors
    Return false
If number is behind middle door
   Return true
Else if number < middle door
   Search left half
Else if number > middle door
   Search right half
   
efficency:
upper bound on the running time: O(log n) max
lower bound on the running time: Ω(1) min


SELECTION SORT: 
upper bound: n(n + 1)/2 = n*2/2 + n/2 = O(n*2) slow
lower bound: Ω(n*2) slow

Pseudo code:
For i from 0 to n-1
   Find smallest item between i'th item and last item
   Swap smallest item with i'th item


BUBBLE SORT: the biggest numbers start bubbling their way to the end of the list
We look at pair of numbers and move the bigger number to the right side of the pair and repeat, 
so the highest number goes to the back of the list

Pseudo code:
Repeat until sorted
   For i from 0 to n-2
      If i'th and i+1'th elemens out of order
         Swap them
   If no swap
      Quit
      
lower bound: Ω(n)
upper bound: (n - 1)x(n - 1) = O(n*2) equivalent to the selection sort: slow


RECURSION or MERGE SORT: the ability for a function to call itself
Uses more space as it needs a second array

Pseudo code:
If only one number
   Quit
Else
   Sort right half of numbers    # sort = sort left, sort right and merge
   Sort left half of numbers
   Merge sorted halves

merge: the smallest number of the combined array needs to begin with either 
       the smallest number of the left or right array, we then build the 
       sorted array with picking the smallest numbers
We sort 4 to halves, and then halves to 1, sort each halves (arrays of sizes 2) and then merge them to array size 4

lower bound: Ω(log n) fast
upper bound: O(n log n) fast

----------------------------------------------------------------------------------------------------------------------------

hexadecimal: BASE-16: 16 digits: 0 1 2 3 4 5 6 7 8 9 A B C D E F
00 01 02 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 18 19 1A ...
255: EIGHT BITS OF 1 OR TWO HEXADECIMAL DIGITS: 11111111 = FF
WE MARK HEXADECIMAL DIGITS to make a difference from normal numbers: 0x48

000000: black
FFFFFF: white
FF0000: red
00FFOO: green
0000FF: blue


int main(void)
{
   int n = 50;
   printf("%p\n", &n); # address of 'n'
}

TERMINAL gives us: 0x7ffd80792f7c # in hexadecimals

address of the number 50 may be for example: 0x12345678 (every number has an address)

&: address of an operator
*: go to the following address
*&: combination of both gives us 50


POINTER: a variable, that contains an address of some other value (integer, bool, and so on) 
int *p = pointer: tend to take 8 bytes

int main(void)
{
   int n = 50;
   int *p = &n; # we are storing the address of n in *p
   printf("%p\n", &n); 
}
TERMINAL: we get *p: the address of the int n


int main(void)
{
   int n = 50;
   int *p = &n;
   printf("%i\n", *p); 
}
TERMINAL: we get the number 50

string s = "HI!" 
H I ! \0: we can assign each letter as a part of array or as an address: there is one number of difference between each letter
H = 0x123  I = 0x124 ...
s = variable = 0x123 string is an address of the first character of the address


#include <cs50.h>
#include <stdio.h>

int main(void)
{
   string s = "HI!"
   printf("%p\n", &s[0]); # show string s as an address/pointer
   printf("%p\n", &s[1]); # show the address of the second character
}
TERMINAL: gives us two addresses of the two characters: similar, only the last digits are different
0x0987
0x0988

STRINGS are pointers: you can always find the whole word if you know where the first letter is as the word ends with \0

POINTER VARIABLE: 
string s = char *s


#include <stdio.h>

int main(void)
{
   char *s = "HI!"
   printf("%c\n", *s);
   printf("%c\n", *(s+1)); #the same as square brackets notation s[]
   printf("%c\n", *(s+2)); # we can got tp the character that is 2 bytes away from character s
}
TERMINAL: HI!


COMPARE TWO VARIABLES:
#include <cs50.h>
#include <stdio.h>

int main(void)
{
   char *s = get_string("s: "); # s stores the adress of the first character of the s string: s is a variable, pointing at a variable 
   char *t = get_string("t: "); # t is a variable, pointing at a variable
   
   printf("%p\n", s);
   printf("%p\n", t);
}
TERMINAL: even if we type the same thing two times, the adresses will be different


#include <cs50.h>
#include <stdio.h>
#include <string.h>

int main(void)
{
   char *s = get_string("s: ");
   char *t = get_string("t: ");
   
   if (strcmp(s, t) == 0)
   {
      printf("Same\n"):
   }
   else
   {
      printf("Different\n");
   }
}
TERMINAL: if we type the same string two times, it prints 'same', otherwise it prints 'different'


COPYING ONE STRING INTO ANOTHER:

#include <cs50.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h> # includes malloc
#include <ctype.h>

int main(void)
{
   char *s = get_string("s: ");
   
   char *t = malloc(strlen(s) + 1);   # give me as much space as is the length of the string + 1 for NUL character
   if (t == NULL)
   {
      return 1;  # in case there is memory-loss, quit
   }
   
   for (int i = 0, n = strlen(s); i <= n; i++)   # <= : we have n + 1 characters (we have to count NUL)
   {
      t[i] = s[i];
   }
   
   if (strlen(t) > 0)
   {
      t[0] = toupper(t[0]);
   }
   
   printf("s: %s\n", s);
   printf("t: %s\n", t);
   
   free(t);   # we are freeing the space the variable t used
}

TERMINAL: returns the lowercase and the uppercase verion where only the first letter is capitalised

malloc: memory allocation
toupper: capitalising the letter
NULL: no adress

copying one string into another: instead of loop, we can use another function: strcopy(s, t);
we are duplicating the string into a  different space in memory

for (int i = 0, n = strlen(s); i <= n; i++)   # <= : we have n + 1 characters (we have to count NUL)
   {
      t[i] = s[i];
   }

malloc: we ask the computer for memory, but eventually it can run out of it, as it is finite, so we have to always free it afterwards

----------------------------------------------------------------------------------------------------------------------------
VALGRIND: we can run it on our code to find memory bugs
valgrind ./name_of_the_program

int main(void)
{
   int *x;
   int *y
   
   x = malloc(sizeof(int));    # we allocate the pointer to pointee
   
   *x = 42;      # at that address (*x) we are putting 42
   *y = 13;      # put 13 at the address of y
  
  y = x;   # y points to the same place as x
  
  *y = 13;
}

GARBAGE VALUE: 
Allocating a variable ensures that any memory for that variable is reserved. 
If a variable is assigned but not allocated in some programming languages such as C, 
it is said to have a garbage value, such that, certain data kept by some random set 
of the storage of the computer.


SWAPING THE NUMBERS IN VARIABLES (passing the values from one function to another):
void swap(int *a, int *b)

int main(void)
{
   int x = 1;
   int y = 2;
   
   printf("x is %i, y is %i\n, x, y);
   swap(&x, &y);
   printf("x is %i, y is %i\n, x, y);
}

void swap(int *a, int *b) # pointers
{
   int tmp = *a;  # tmp is an integer, *a and *b are addresses
   *a = *b;
   *b = tmp;
}

STACK(functions): place where memory gets used and reused
stack overflow: calling a function so many times that it overflows the area of memory called heap
buffer overflow: going beyond the boundry of the memory


scanf

get_int is the same as all the code below

#include <stdio.h>

int main(void)
{
   int x;
   printf("x: ");
   scanf("%i, &x");
   printf("x: %i\n", x);
}

get_string

#include <stdio.h>

int main(void)
{
   char s[4]; # we allocate 4 bytes of memory
   printf("s: ");
   scanf("%s, s");
   printf("s: %s\n", s);
}

----------------------------------------------------------------------------------------------------------------------------
file I/O

this program prompts a user for name and number and then add them to the file

int main(void)
{
   FILE *file = fopen("phonebook.csv", "a");
   if (file == NULL)
   {
      return 1;
   }
   
   char *name = get_string("Name: ");  
   char *name = get_string("Name: ");  
   
   fprintf(file, "%s,%s\n", name, number) 
   
   fclose(file);
}

after inputing the numbers and names: we can download the file and open it

----------------------------------------------------------------------------------------------------------------------------

DATA STRUCTURES:

LINKED LIST: connected nodes (data structures)
when we cannot make an array (numbers in order, one after another), 
therefore numbers are spread randomly in memory, we can add a node to each number
that we want in an array (by adding information (address) about the next number in list)
and that creates a linked list: we can now connect random numbers without moving them (saves time),
but we use more space


typedef struct node   # 'node' here is used as a clue to let the machine know that it is defined later on
{
   int number;   # describes the top of the data structure
   struct node *next;   # pointer to the next node
}
node;

malloc enables us to reserve space for elements of the linked list


node *list = NULL; # empty linked list, not pointing anything

node *n = malloc(sizeof(node)); # we allocate memory space for the first element: n is currently pointing to empty node (garbage value)

if (n != NULL)  # with pointers we have to always check if it is NULL or not, in case it is, we quit
{
   n->number = 1;  # if n is not NULL, follow the pointer, go inside the variable called 'number' and place number 1 there (same as (*n).number)
}

list = n;  # before than, 'n' was a temporary variable, but now it is a part of the linked list (linked list of size one)


node *n = malloc(sizeof(node));
if (n != NULL)
{
   n->number = 2;
   n->next = NULL;  # pointer of 'n' is still NULL
}
list->next = n;


node *n = malloc(sizeof(node));
if (n != NULL)
{
   n->number = 3;
   n->next = NULL; 
}
list->next->next = n; # linked list of size 3



CREATING A LIST AND RESIZING IT
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
   int *list = malloc(3 * sizeof(int));  #we can resize malloc
   if (list == NULL)
   {
      return 1;
   }
   
   list[0] = 1;
   list[1] = 2;
   list[2] = 3;
   
   int *tmp = malloc(4 * sizeof(int));  # we want to add a 4th value: we allocate space for 4 int
   if (tmp == NULL)
   {
      free(list);
      return 1;
   }
   
   for (int i = 0; i < 3; i++)  # copy list into a temporary chunk of memory
   {
      tmp[i] = list[i];
   }
   
   tmp[3] = 4;  # we add the 4th number
   
   free(list);
   
   list = tmp;
   
   for (int i = 0; i < 4; i++)
   {
      printf("%i\n", list[i]);
   }
}
TERMINAL PRINTS THE LIST

int *tmp = malloc(4 * sizeof(int));
instead of this we can use realloc(list, 4 * sizeof(int));  # takes 2 arguments
using this, we don't need to store/copy anything into tmp 


#include <stdio.h>
#include <stdlib.h>

typedef struct node
{
   int number;
   struct node *next;
}
node;

int main(void)
{
   node *list = NULL;
   
   node *n = malloc(sizeof(node));
   if (n == NULL)
   {
      return 1;
   }
   n->number = 1;
   n->next = NULL;
   list = n;
   
   n = malloc(sizeof(node));
   if (n== NULL)
   {
     free(list);
     return 1;
   }
   
   n->number = 2;
   n->next = NULL;
   list->next = n;
   
   n = malloc(sizeof(node));
   if (n== NULL)
   {
     free(list->next);
     free(list);
     return 1;
   }
   
   n->number = 3;
   n->next = NULL;
   list->next->next = n;
   
   for(node *tmp = list; tmp != NULL; tmp = tmp->next) 
   {
      printf("%i\n", tmp->number);
   }
   
   while (list != NULL)   # freeing the list 
   {
      node *tmp = list->next;  # when we add the value to the list, 
      free(list);                we point to the next value and free 
     list = tmp;                 the one we already used and continue the loop
   }
}

we have a temporary variable 'tmp' where we store the 
variable n, move to the next pointer and store the value 
and so forth until we reach NULL at the end of pointer


adding nodes in the middle: order of operations matter

n->next = list;
list = n;


TREES:
binary search tree: finding a number in a downward positioned tree: must be balanced
   4
 2   6
1 3 5 7 

typedef struct node
{
   int number;
   struct node *left;
   struct node *right;
}

recursion:
bool search(node *tree, int number)
{
   if (tree == NULL)
   {
      return false;
   }
   else if (number < tree->number)
   {
      return search(tree->left, number);
   }
   else if (number > tree->number)
   {
      return search(tree->right, number);
   }
   else
   {
      return true;
   }
}

----------------------------------------------------------------------------------------------------------------------------
HASH TABLE: data structure that is an array of linked lists: storing information to get it more quickly
HASH FUNCTION: function that takes as input a string and returns a numeric output
we can solve smaller problems quicker: we want to minimise the number of elements that collide


TRIE: a tree with nodes, made up of arrays: each node is a pointer to another array/node/pointer

 H     CONSTANT TIME: O(n): we can find a certain string with only as many steps as is the length of the array
 A                          with Hagrid we only need 6 steps to find it in the phonebook (dependant only on the length of the name)
G R    disadvantage: not efficient use of space
R R
I Y
D


ABSTRACT DATA STRUCTURES: can be implemented with linked lists, hash tables, arrays, ...

QUEUE: first in-first out: FIFO
enqueue: getting into a line
dequeue: getting out of the line

STACK: last in-first out: LIFO (stack of clothes)
push: getting the value onto the stack
pop: removing the value off of the stack

DICTIONARY: associating keys with values (definitions)




















